# This is a sample Python script.
import numpy as np
from demo_ncup import sort_humanly
import time
import cv2
import os


def init(path,mask_path,save_root):
    # Use a breakpoint in the code line below to debug your script.
    name=os.path.split(path)[-1]
    print('now:',name)
    if not os.path.exists(save_root):
        os.makedirs(save_root)
    save_name=os.path.join(save_root,name)
    image = cv2.imread(path)
    mask = cv2.imread(mask_path, cv2.IMREAD_GRAYSCALE)
    kernel = np.ones((3, 3), np.uint8)
    mask = cv2.dilate(mask, kernel, iterations=1)
    if np.max(mask)==0 :
        cv2.imwrite(save_name, mask)
        return
    # apply a bitwise mask to show what the rough, approximate mask would
    # give us
    roughOutput = cv2.bitwise_and(image, image, mask=mask)
    # # show the rough, approximated output
    mask[mask > 0] = cv2.GC_PR_FGD
    mask[mask == 0] = cv2.GC_BGD
    # allocate memory for two arrays that the GrabCut algorithm internally
    # uses when segmenting the foreground from the background
    fgModel = np.zeros((1, 65), dtype="float")
    bgModel = np.zeros((1, 65), dtype="float")
    # apply GrabCut using the the mask segmentation method
    start = time.time()
    (mask, bgModel, fgModel) = cv2.grabCut(image, mask, None, bgModel,
                                           fgModel, iterCount=5, mode=cv2.GC_INIT_WITH_MASK)
    end = time.time()
    print("[INFO] applying GrabCut took {:.2f} seconds".format(end - start))

    # values = (
    #     ("Definite Background", cv2.GC_BGD),
    #     ("Probable Background", cv2.GC_PR_BGD),
    #     ("Definite Foreground", cv2.GC_FGD),
    #     ("Probable Foreground", cv2.GC_PR_FGD),
    # )
    # # loop over the possible GrabCut mask values
    # for (name, value) in values:
    #     # construct a mask that for the current value
    #     print("[INFO] showing mask for '{}'".format(name))
    #     valueMask = (mask == value).astype("uint8") * 255
    #     # display the mask so we can visualize it
    #     cv2.imshow(name, valueMask)
    #     cv2.waitKey(0)
    # set all definite background and probable background pixels to 0
    # while definite foreground and probable foreground pixels are set
    # to 1, then scale teh mask from the range [0, 1] to [0, 255]
    outputMask = np.where((mask == cv2.GC_BGD) | (mask == cv2.GC_PR_BGD),
                          0, 1)
    outputMask = (outputMask * 255).astype("uint8")
    # apply a bitwise AND to the image using our mask generated by
    # GrabCut to generate our final output image
    output = cv2.bitwise_and(image, image, mask=outputMask)
    cv2.imwrite(save_name,outputMask)

    # show the input image followed by the mask and output generated by
    # GrabCut and bitwise masking
    # cv2.imshow("Input", image)
    # cv2.imshow("GrabCut Mask", outputMask)
    cv2.imshow("GrabCut Output", output)
    cv2.imshow("Rough Output", roughOutput)
    cv2.waitKey(1)
# Press the green button in the gutter to run the script.
if __name__ == '__main__':
    # path, mask_path=r'./data/img/00001.jpg',r'./data/mask/00001.jpg'
    # path_root, mask_root=r'F:\semantic_segmentation_unet\data\val_images',r'F:\semantic_segmentation_unet\data\val_masks'
    path_root, mask_root=r'F:\RAFT-NCUP-master\tracing',r'F:\RAFT-NCUP-master\output_iter20'
    save_root = r'output_iter20_tracing_refine'

    path= os.listdir(path_root)
    mask_path= os.listdir(mask_root)

    path = sort_humanly(path)
    mask_path = sort_humanly(mask_path)
    for img,mask in zip(path,mask_path):
        img= os.path.join(path_root,img)
        mask= os.path.join(mask_root,mask)
        init(img, mask,    save_root )

# See PyCharm help at https://www.jetbrains.com/help/pycharm/
